---
title: "Handling incidence objects"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Handling incidence objects}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.align = "center",
  fig.width = 7,
  fig.height = 5
)
```

`incidence()` objects are easy to work with, and we providing helper functions
for both manipulating and accessing the underlying data and attributes.

## Modifying incidence objects

### `regroup()`
Sometimes you may find you've created a grouped incidence but now want to change
the internal grouping. Assuming you are after a subset of the grouping already
generated, then you can use to `regroup()` function to get the desired
aggregation:

```{r regroup, message=FALSE}
library(outbreaks)
library(incidence2)
library(grates)

# load data
dat <- ebola_sim_clean$linelist

# convert date_of_onset to isoweeks
dat$date_of_onset <- as_isoweek(dat$date_of_onset)

# generate the incidence object with 3 groups
(inci <- incidence(dat, "date_of_onset", groups = c("gender", "hospital", "outcome")))

# regroup to just two groups
regroup(inci, c("gender", "outcome"))

# drop all groups
regroup(inci)
```

### cumulate
We also provide a helper function, `cumulate`() to easily generate cumulative 
incidences:

```{r cumulate}
x <- regroup(inci, "hospital")
x <- cumulate(x)
plot(x, nrow = 3)
```

### `keep_first()` and `keep_last()`
Once your data is grouped by date, you may want to select the first or last few
entries based on a particular date grouping using `keep_first()` and
`keep_last()`:

```{r keep}
keep_first(inci, 3)
keep_last(inci, 3)
```

### subsetting and other manipulations
`<incidence>` objects have been carefully constructed to preserve their
structure under a range of different operations that can be applied to data
frames. By this we mean that if an operation is applied to an `<incidence>`
object then as long as the invariants of the object are preserved (i.e. groups,
interval and uniqueness of rows) then the object retain it's incidence class.
If the invariants are not preserved then a `<data frame>` will be returned
instead.

```{r subsetting}
inci <- regroup(inci, groups = c("hospital", "gender"))

# filtering preserves class
subset(inci, gender == "f" & hospital == "Rokupa Hospital")
inci[c(1L, 3L, 5L), ]

# Adding columns preserve class
inci$future <- inci$date_index + 999L
inci

# rename preserve class
names(inci)[names(inci) == "date_index"] <- "isoweek"
inci

# select returns a data frame unless all date, count and group variables are
# preserved in the output
str(inci[,-1L])
inci[, -6L]
```

## Accessing variable information

We provide multiple accessors to easily access information about an
`<incidence>` object's structure:

```{r accessors}
# the name of the date_index variable of x
get_date_index_name(inci)

# alias for `get_date_index_name()`
get_dates_name(inci)

# the name of the count variable of x
get_count_variable_name(inci)

# the name of the count value of x
get_count_value_name(inci)

# the name(s) of the group variable(s) of x
get_group_names(inci)

# list containing date_index variable of x
str(get_date_index(inci))

# alias for get_date_index
str(get_dates(inci))

# list containing the count variable of x
str(get_count_variable(inci))

# list containing count value of x
str(get_count_value(inci))

# list of the group variable(s) of x
str(get_groups(inci)) 
```
