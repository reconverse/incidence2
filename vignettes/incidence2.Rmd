---
title: "incidence2"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{incidence2}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.align = "center",
  fig.width = 7,
  fig.height = 5
)
```

## What does it do?

**incidence2** is an R package that implements functions and classes to compute,
handle and visualise *incidence* data. It aims to be intuitive to use for both
interactive data exploration and as part of more robust outbreak analytic 
pipelines.

### Overview

The main feature of the package is the `incidence()` function which works on
both linelist and pre-aggregated data sets. It returns an object of class
`<incidence>`. This is a data frame subclass with some additional invariants.
That is, an `<incidence>` object must:
  
- have one column representing the date index (this does not need to be a `date`
  object but must have an inherent ordering over time);
  
- have one column representing the count variable (i.e. what is being counted)
  and one variable representing the associated count;
  
- have zero or more columns representing groups;

- not have duplicated rows with regards to the date and group variables.
    
### Additional functionality

- `plot.incidence()`: generate simple plots with reasonable defaults.

- `regroup()`: regroup incidence from different groups into one global incidence
  time series.
  
- `keep_first()` and `keep_last()`: keep the rows corresponding to the first (or
  last) set of grouped dates (ordered by time) from an `<incidence>` object.
  
- `complete_dates()`: ensure every possible combination of date and groupings
  is represented with a count.
  
- `cumulate()`: calculate the cumulative incidence over time.
  
- `print.incidence()` and `summary.incidence()` methods.

- `as.data.frame.incidence()` conversion method.

- Accessor functions for accessing underlying variables: `get_date_index()`,
  `get_count_variable()`, `get_count_value()`, `get_groups()`,
  `get_count_value_name()`, `get_count_variable_name()`, `get_date_index_name()`
  and `get_group_names()`.

### Example usage: computing and plotting incidence

```{r}
library(outbreaks)  # for the underlying data
library(ggplot2)    # For custom plotting later
library(incidence2) 
```

This example uses the simulated Ebola Virus Disease (EVD) outbreak from the
package [outbreaks](https://github.com/reconverse/outbreaks). 

```{r data}
dat <- ebola_sim_clean$linelist
str(dat)
```

To compute daily incidence we pass to `incidence()` a *data.frame* of
observation data. We must also pass the name of a variable in the data that we
can use to index the input. Note that whilst we we refer to this index as the
`date_index` there is no restriction on it's type save that it can be used to
represent the relative time of an observation:

```{r daily, fig.height = 5, dpi = 90}
(daily <- incidence(dat, date_index = "date_of_onset"))
plot(daily)
```

The daily data is quite noisy, so we may want to pre group dates prior to
calculating the incidence. One way to do this is to utilise functions from the
[grates](https://www.reconverse.org/grates/dev/) package. Here we use the
`as_isoweek()` function to calculate the weekly (starting on a Monday)
incidence:

```{r}
# 7 day incidence
weekly_dat <- transform(dat, date_of_onset = as_isoweek(date_of_onset))
(inci <- incidence(weekly_dat, date_index = "date_of_onset"))
plot(inci, border_colour = "white")
```

We prefer grouping dates prior to calling `incidence()` as it makes it very
clear to readers of your code what transformations are being applied to your
input data. That said, it is such a common and useful operation that we have
integrated much of
[grates'](https://www.reconverse.org/grates/dev/) functionality in to 
incidence2. We do this via an `interval` parameter which can take values:

- week(s), isoweek(s) or weekly (mapping to `<grates_isoweek>`);
- epiweek(s) (mapping to `<grates_epiweek>`);
- month(s), yearmonth(s) or monthly (`<grates_yearmonth>`);
- quarter(s), yearquarter(s) or quarterly (`<grates_yearquarter>`);
- year(s) or yearly (`<grates_year>`).

For example, the following is equivalent to the `inci` output above:

```{r sevenday}
# equivalent - using `interval` argument
(inci2 <- incidence(dat, date_index = "date_of_onset", interval = "isoweek"))
identical(inci, inci2)
```

If we wish to aggregate by specified groups we can use the `groups` argument.
For instance, computing incidence by gender:

```{r gender}
(grouped_inci <- incidence(
    dat,
    date_index = "date_of_onset",
    groups = "gender",
    interval = "isoweek"
))
```

For grouped data, the plot method will create a faceted plot across groups:

```{r genderplot}
plot(grouped_inci, border_colour = "white", angle = 45)
```

Similarly, `incidence()` also supports multiple date inputs where the different
date indices are used for filling the resultant plot
```{r}
(grouped_inci <- incidence(
    dat,
    date_index = c(
        onset = "date_of_onset",
        infection = "date_of_infection"
    ), 
    interval = "isoweek"
))

plot(grouped_inci, angle = 45, border_colour = "white")
```

Note that although the plot method for `<incidence>` objects tries to balance
flexibility with simplicity it can be preferable to call ggplot2 directly on the
underlying data.
